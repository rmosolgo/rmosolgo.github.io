<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2019-01-29T09:15:56-05:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A New Runtime in GraphQL-Ruby 1.9]]></title>
    <link href="http://rmosolgo.github.io/blog/2019/01/29/a-new-runtime-in-graphql-ruby-1-dot-9/"/>
    <updated>2019-01-29T07:22:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2019/01/29/a-new-runtime-in-graphql-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>GraphQL-Ruby 1.9.0 introduces a new runtime called <code>GraphQL::Execution::Interpreter</code>. It offers better performance and some new features.</p>

<!-- more -->


<p>In <a href="https://github.com/rmosolgo/graphql-ruby/issues/861#issuecomment-458533219">isolated benchmarks</a>, the new runtime is about 50% faster. We saw about a 10% speedup in GitHub when we migrated.</p>

<p>You can opt in by adding to your schema:</p>

<pre><code class="ruby">class MySchema &lt; GraphQL::Schema
  # To use the new runtime
  use GraphQL::Execution::Interpreter
  # To skip preprocessing (you can use the interpreter without adding this)
  use GraphQL::Analysis::AST
end
</code></pre>

<p>But why rewrite?</p>

<h2>Problem 1: per-field context objects</h2>

<p>Previously, each field evaluated by GraphQL-Ruby got its own instance of <code>GraphQL::Query::Context::FieldResolutionContext</code>. This was introduced so that fields using <code>graphql-batch</code>-style Promises could reliably access context values (like <code>ctx.path</code>) <em>after</em> returning from the resolver (ie, when the promise was synced.)</p>

<p>The problem was, the bigger the response, the more <code>ctx</code> objects would be created &ndash; and most of the time (for example, plain scalar fields), they were never <em>used</em> by application code. So, we allocated, initialized, then GCed these objects for nothing!</p>

<p>In fact, it wasn&rsquo;t for <em>nothing</em>. As time passed, I started using those context objects inside execution code. For example, null propagation was implemented by climbing <em>up</em> the tree of context objects. So you couldn&rsquo;t just <em>stop</em> creating them &ndash; the runtime depended on them.</p>

<h3>Solution: one mutable context</h3>

<p>To remove this performance issue, I went <em>back</em> to creating a single <code>Query::Context</code> object and passing it to resolvers. If you&rsquo;re using the new class-based API, you might have noticed that <code>self.context</code> is a <code>Query::Context</code>, not a <code>Query::Context::FieldResolutionContext</code>. I did it this way to pave the way for removing this bottleneck.</p>

<p>But what about access to runtime information?</p>

<h3>Solution: explicit requests for runtime info</h3>

<p>For fields that <em>want</em> runtime info (like <code>path</code> or <code>ast_node</code>), they can opt into it with <code>extras: [...]</code>, for example:</p>

<pre><code class="ruby">field :items, ..., extras: [:path]
</code></pre>

<p>By adding that configuration, the requested value will be injected into the resolver:</p>

<pre><code class="ruby">def items(path:)
  # ...
end
</code></pre>

<p><code>path</code> will be a frozen Array describing the current point in the GraphQL response.</p>

<h3>Solution: reimplementing the runtime</h3>

<p>Finally, since <code>FieldResolutionContext</code>s aren&rsquo;t necessary for user code, we can rewrite execution to <em>not</em> create or use them anymore. Under the hood, <code>GraphQL::Execution::Interpreter</code> doesn&rsquo;t create those <code>ctx</code> objects. Instead, null propagation is implemented manually and all necessary values are passed from method to method.</p>

<h2>Problem 2: inefficient preprocessing</h2>

<p>Years ago, someone requested the feature of <em>rejecting a query before running it</em>. They wanted to analyze the incoming query, and if it was too big or too complicated, reject it.</p>

<p>How could this be implemented? You could provide user access to the AST, but that would leave some difficult processing to user code, for example, merging fragments on interfaces.</p>

<p>So, I added <code>GraphQL::InternalRepresentation</code> as a normalized, pre-processed query structure. Before running a query, the AST was transformed into a tree of <code>irep_node</code>s. Users could analyze that structure and reject queries if desired.</p>

<p>In execution code, why throw away the result of that preprocessing? The runtime also used <code>irep_node</code>s to save re-calculating fragment merging.</p>

<p>In fact, even <em>static validation</em> used the <code>irep_node</code> tree. At some point, rather than re-implement fragment merging, I decided to hook into that rewritten tree to implement <code>FragmentsWillMerge</code>. After all, why throw away that work?</p>

<p>(As it turns out, someone should fire the GraphQL-Ruby maintainer. These layers of code were <em>not</em> well-isolated!!)</p>

<h3>Problem 2.1: Preparing the <code>irep_node</code>s was slow and often a waste</h3>

<p>Since the <code>irep_node</code> tree was built for <em>analysis</em>, it generated branches for <em>every</em> possible combination of interfaces, objects, and unions. This meant that, even for a query returning very simple data, the pre-processing step might be <em>very</em> complex.</p>

<p>To make matters worse, the complexity of this preprocessing would grow as the schema grew. The more implementers an interface has, the longer it takes to calculate the possible branches in a fragment.</p>

<h3>Problem 2.2: Runtime features were implemented during preprocessing</h3>

<p>Not only was the work complex, but it also couldn&rsquo;t be cached. This is because, while building the <code>irep_node</code> tree, <code>@skip</code> and <code>@include</code> would be evaluated with the current query variables. If nodes were skipped, they were left out of the <code>irep_node</code> tree.</p>

<p>This means that, for the <em>same</em> query in your code base, you <em>couldn&rsquo;t</em> reuse the <code>irep_node</code> tree, since the values for those query variables might be different from one execution to the next. Boo, hiss!</p>

<h3>Problem 2.3: A wacky preprocessing step is hard to understand</h3>

<p>I want to empower people to use GraphQL-Ruby in creative ways, but throwing a wacky, custom data structure in the mix doesn&rsquo;t make it easy. I think an easier execution model will encourage people to learn how it works and build cool new stuff!</p>

<h3>Solution: No preprocessing</h3>

<p>The new runtime evaluates the AST directly. Runtime features (<code>@skip</code> and <code>@include</code>, for example) are implemented at, well, <em>runtime</em>!</p>

<h3>Solution: AST Analyzers</h3>

<p>Since you can&rsquo;t use the <code>irep_node</code> tree for analysis anymore, the library includes a new module, <code>GraphQL::Analysis::AST</code>, for preprocessing queries. Shout out to <a href="https://github.com/xuorig">@xuorig</a> for this module!</p>

<h3>Solution: Moving ahead-of-time checks to runtime</h3>

<p>For GitHub, we moved a lot of analyzer behavior to runtime. We did this because it&rsquo;s easier to maintain and requires less GraphQL-specific knowledge to understand and modify. Although the client experience is <em>slightly</em> different, it&rsquo;s still good.</p>

<p>For example, we had an analyzer to check that pagination parameters (eg <code>first</code> and <code>last</code>) were valid. We moved this to runtime, adding it to our connection tooling.</p>

<h3>Solution: <code>GraphQL::Execution::Lookahead</code></h3>

<p><code>irep_node</code>s <em>were</em> useful for looking ahead in a query to see what fields would be selected next. (Honestly, they weren&rsquo;t <em>that good</em>, but they were the only thing we had, beside using the AST directly).</p>

<p>To support that use, we now have <code>extras: [:lookahead]</code> which will inject an instance of <code>GraphQL::Execution::Lookahead</code>, with an API <em>explicitly for</em> checking fields later in the query.</p>

<h2>Other considerations</h2>

<h3>Resolve procs are out</h3>

<p>As part of the change with removing <code>FieldResolutionContext</code>, the new runtime doesn&rsquo;t support proc-style resolvers <code>-&gt;(obj, args, ctx) {...}</code>. Besides <code>ctx</code>, the <code>args</code> objects (<code>GraphQL::Query::Arguments</code>) are not created by the interpreter either. Instead, the interpreter uses plain hashes.</p>

<p>Instead of procs, methods on Object type classes should be used.</p>

<p>This means that proc-based features are also not supported. Field instrumenters and middlewares won&rsquo;t be called; a new feature called field extensions should be used instead.</p>

<h3><code>.to_graphql</code> is <em>almost</em> out</h3>

<p>When the class-based schema API was added to GraphQL-Ruby, there was a little problem. The class-based API was great for developers, but the execution API expected legacy-style objects. The bridge was crossed via a compatibility layer: each type class had a <code>def self.to_graphql</code> method which returned a legacy-style object based on that class. Internally, the class and legacy object were cached together.</p>

<p>The interpreter <em>doesn&rsquo;t</em> use those legacy objects, only classes. So, any type extensions that you&rsquo;ve built will have to be supported on those <em>classes</em>.</p>

<p>The catch is, I&rsquo;m not <em>100% sure</em> that uses of legacy objects have all been migrated. In GitHub, we transitioned by delegating methods from the legacy objects to their source classes, and I haven&rsquo;t removed those delegations yet. So, there might still be uses of legacy objects ðŸ˜….</p>

<p>In a future version, I want to remove the use of those objects <em>completely</em>!</p>

<h1>Conclusion</h1>

<p>I hope this post has clarified some of the goals and approaches toward adding the new runtime. I&rsquo;m already building new features for it, like custom directives and better subscription support. If you have a question or concern, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> to discuss!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trampolining]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/09/23/trampolining/"/>
    <updated>2018-09-23T21:04:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/09/23/trampolining</id>
    <content type="html"><![CDATA[<p>As part of my work on <a href="https://github.com/rmosolgo/graphql-ruby/pull/1394">improving GraphQL-Ruby&rsquo;s runtime performance</a>, I&rsquo;ve been reading <a href="http://www.eopl3.com/"><em>Essentials of Programming Languages</em></a>. Here, I try to apply their lesson about &ldquo;trampolining&rdquo;.</p>

<!-- more -->


<p><strong>TL;DR:</strong> I applied a thing I read in a textbook and it:</p>

<ul>
<li>reduced the stack trace size by 80%</li>
<li>reduced the live object count by 15%</li>
<li>kept the same runtime speed</li>
</ul>


<p>You can see the diff and benchmark results here: <a href="https://github.com/rmosolgo/graphql-ruby/compare/1b306fad...eef73b1">https://github.com/rmosolgo/graphql-ruby/compare/1b306fad...eef73b1</a></p>

<h2>The Problem</h2>

<p>It&rsquo;s a bit funny, but it&rsquo;s not <em>totally clear</em> to me what the book is trying to get at here. In the book, they talk about <em>control context</em> or <em>continuations</em> in a way that I would talk about &ldquo;stack frames&rdquo;. I think the problem is this: when you implement a programming language as an interpreter, you end up with recursive method calls, and that recursion builds up a big stack in the host language. This is bad because it hogs memory.</p>

<p>I can definitely <em>imagine</em> that this is a problem in Ruby, although I haven&rsquo;t measured it. GraphQL-Ruby uses recursion to execute GraphQL queries, and I can <em>imagine</em> that those recursive backtrace frames hog memory for a couple reasons:</p>

<ul>
<li>The control frames themselves (managed by YARV or something) take up memory in their own right</li>
<li>The control frames each have a lexical scope (<code>binding</code>), which, since it&rsquo;s still on the stack, can&rsquo;t be GCed. So, Ruby holds on to a lot of objects which <em>could</em> be garbaged collected if the library was written better.</li>
</ul>


<p>Besides that, the long backtrace adds a lot of noise when debugging.</p>

<h2>Trampolining</h2>

<p>In the book, they say, &ldquo;move your recursive calls to tail position, then, assuming your language has tail-call optimization, you won&rsquo;t have this problem.&rdquo; Well, my language <em>doesn&rsquo;t</em> have tail-call optimization, so I <em>do</em> have this problem! (Ok, it&rsquo;s an <a href="https://ruby-doc.org/core-2.4.0/RubyVM/InstructionSequence.html#method-c-compile_option-3D">option</a>.)</p>

<p>Luckily for me, they describe a technique for solving the problem <em>without</em> tail-call optimization. It&rsquo;s called <em>trampolining</em>, and it works roughly like this:</p>

<blockquote><p>When a method <em>would</em> make a recursive call, instead, return a <code>Bounce</code>. Then, the top-level method, which previously received the <code>FinalValue</code> of the interpreter&rsquo;s work, should be extended to accept <em>either</em> a <code>FinalValue</code> or a <code>Bounce</code>. In the case of a <code>FinalValue</code>, it returns the value as previously. In the case of a <code>Bounce</code>, it re-enters the interpreter using the &ldquo;bounced&rdquo; value.</p></blockquote>

<p>Using this technique, a previously-recursive method now <em>returns</em>, giving the caller some information about how to take the next step.</p>

<p>Let&rsquo;s give it a try.</p>

<h2>The Setup</h2>

<p>I want to test impact in two ways: memory consumption and backtrace size. I want to measure these values <em>during</em> GraphQL execution, so what better way to do it but build a GraphQL schema!</p>

<p>You can see the <a href="https://github.com/rmosolgo/graphql-ruby/compare/1b306fad...eef73b1#diff-7a29575d7b0f8a35812f9323ee46febe">whole benchmark</a>, but in short, we&rsquo;ll run a deeply-nested query, and at the deepest point, measure the <em>backtrace size</em> and the number of live objects in the heap:</p>

<pre><code class="ruby">{
  nestedMetric {
    nestedMetric {
      nestedMetric {
        # ... more nesting ...
        nestedMetric {
          backtraceSize
          objectCount
        }
      }
    }
  }
}
</code></pre>

<p>Where the fields are implemented by:</p>

<pre><code class="ruby">def backtrace_size
  caller.size
end

def object_count
  # Make a GC pass
  GC.start
  # Count how many objects are alive in the heap,
  # subtracting the number of live objects before we started
  GC.stat[:heap_live_slots] - self.class.object_count_baseline
end
</code></pre>

<p>We&rsquo;ll use these measurements to assess the impact of the refactor.</p>

<h2>The Pledge: Recursive calls</h2>

<p>To begin with, the interpreter is implemented as a set of recursive methods. The methods do things like:</p>

<ul>
<li>Given an object and a set of selections, resolve the selected fields on that object</li>
<li>Given a value and a type, prepare the value for a GraphQL response according to the type</li>
</ul>


<p>These methods are <em>recursive</em> in the case of fields that return GraphQL objects. The first method resolves a field and calls the second method; then the second method, in order to prepare an object as a GraphQL response, calls back to the first method, to resolve selections on that object. For example, execution might work like this:</p>

<ul>
<li>Resolve selections on the root object

<ul>
<li>One of the selections returned a User

<ul>
<li>Resolve selections on the User

<ul>
<li>One of the selections returns a Repository

<ul>
<li>Resolve selections on the Repository

<ul>
<li>&hellip;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>Do you see how the same procedure is being applied over and over, in a nested way? That&rsquo;s implemented with recursive calls in GraphQL-Ruby.</p>

<p>We can run our test to see how the Ruby execution context looks in this case:</p>

<pre><code class="ruby"># $ ruby test.rb
1b306fad3b6b35dd06248028883cd8a3ec4bdefd
{"backtraceSize"=&gt;282, "objectCount"=&gt;812}
</code></pre>

<p>This is the baseline for backtrace size and object count, which we&rsquo;re using to measure <em>memory overhead</em> in GraphQL execution. (This describes behavior at <a href="https://github.com/rmosolgo/graphql-ruby/commit/2401afc4a19f2e5616e1e155f953ec403bf4896c">this commit</a>.)</p>

<h2>The Turn: Moving Recursive Calls into Tail Position</h2>

<p>As a requirement for the final refactor, we have to do some code reorganization. In the current code, the recursive calls require some setup and teardown around them. For example, we track the GraphQL &ldquo;path&rdquo;, which is the list of fields that describe where we are in the response. Here&rsquo;s a field with its &ldquo;path&rdquo;:</p>

<pre><code class="ruby">{
  a {
    b {
      c # The path of this field ["a", "b", "c"]
    }
  }
}
</code></pre>

<p>In the code, it looks something like this:</p>

<pre><code class="ruby"># Append to the path for the duration of the nested call
@path.push(field_name)
# Continue executing, with the new path in context
execute_recursively(...)
# Remove the entry from `path`, since we're done here
@path.pop
</code></pre>

<p>The problem is, if I want to refactor <code>execute_recursively</code> to become a <code>Bounce</code>, it won&rsquo;t do me any good, because the value of <code>execute_recursively</code> <em>isn&rsquo;t returned</em> from the method. It&rsquo;s not the last call in the method, so its value isn&rsquo;t returned. Instead, the value of <code>@path.pop</code> is returned. (It&rsquo;s not used for anything.)</p>

<p>This is to say: <code>@path.pop</code> is in <em>tail position</em>, the last call in the method. But I want <code>execute_recursively</code> to be in tail position.</p>

<h3>A Hack Won&rsquo;t Work</h3>

<p>The easiest way to &ldquo;fix&rdquo; that would be to refactor the method to return the value of <code>execute_recursively</code>:</p>

<pre><code class="ruby"># Append to the path for the duration of the nested call
@path.push(field_name)
# Continue executing
return_value = execute_recursively(...)
# Remove the entry from `path`, since we're done here
@path.pop
# Manually return the execution value
return_value
</code></pre>

<p>The problem is, when <code>execute_recursively</code> is refactored to be a <code>Bounce</code>:</p>

<pre><code class="ruby"># Append to the path for the duration of the nested call
@path.push(field_name)
# Continue executing
bounce = prepare_bounce(...)
# Remove the entry from `path`, since we're done here
@path.pop
# Manually return the execution value
bounce
</code></pre>

<p>By the time the <code>bounce</code> is actually executed, <code>path</code> <em>won&rsquo;t have</em> the changes I need in it. The value is pushed <em>and popped</em> before the bounce is actually called.</p>

<h3>Pass the Path as Input</h3>

<p>The solution is to remove the need for <code>@path.pop</code>. This can be done by creating a <em>new path</em> and passing it as input.</p>

<pre><code class="ruby"># Create a new path for nested execution
new_path = path + [field_name]
# Pass it as an input
execute_recursively(new_path, ...)
</code></pre>

<p>Now, <code>execute_recursively</code> is in tail position!</p>

<p>(The actual refactor is here: <a href="https://github.com/rmosolgo/graphql-ruby/commit/ef6e94283ecf280b14fe5417a4ee6896a06ebe69">https://github.com/rmosolgo/graphql-ruby/commit/ef6e94283ecf280b14fe5417a4ee6896a06ebe69</a>)</p>

<h2>The Prestige: Make it Bounce</h2>

<p>Now, we want to replace recursive calls with a <em>bounce</em>, where a bounce is an object with enough information to continue execution at a later point in time.</p>

<p>Since my recursive interpreter is implemented with a bunch of stateless methods (they&rsquo;re stateless since the refactor above), I can create a Bounce class that will continue by calling the same method:</p>

<pre><code class="ruby">class Bounce
  # Take the inputs required to call the next method
  def initialize(object, method, *arguments)
    @object = object
    @method = method
    @arguments = arguments
  end

  # Continue by calling the method with the given inputs
  def continue
    @object.send(@method, *@arguments)
  end
end
</code></pre>

<p>Then, I replace the tail-position recursive calls with bounces:</p>

<pre><code class="diff">- execute_recursively(...)
+ Bounce.new(self, :execute_recursively, ...)
</code></pre>

<p>Instead of <em>growing</em> the backtrace by calling another method, we&rsquo;ll be <em>shrinking</em> the backtrace by returning from the current method with a Bounce.</p>

<p>You can see the refactor here: <a href="https://github.com/rmosolgo/graphql-ruby/commit/b8e51573652b736d67235080e8b450d6fc9cc92e">https://github.com/rmosolgo/graphql-ruby/commit/b8e51573652b736d67235080e8b450d6fc9cc92e</a></p>

<h3>How&rsquo;d it work?</h3>

<p>Let&rsquo;s run the test:</p>

<pre><code class="ruby"># $ ruby test.rb
b8e51573652b736d67235080e8b450d6fc9cc92e
{"backtraceSize"=&gt;55, "objectCount"=&gt;686}
</code></pre>

<p>It&rsquo;s a success! The <code>backtraceSize</code> decreased from 282 to 55. The <code>objectCount</code> decreased from <code>812</code> to <code>686</code>.</p>

<h3>Implementation Considerations</h3>

<p><strong>&ldquo;Trampolining&rdquo;</strong> is the process of taking each bounce and continuing it. In my first implementation, <code>def trampoline</code> looked like this:</p>

<pre><code class="ruby"># Follow all the bounces until there aren't any left
def trampoline(bounce)
  case bounce
  when Bounce
    trampoline(bounce.continue)
  when Array
    bounce.each { |b| trampoline(b) }
  else
    # not a bounce, do nothing
  end
end
</code></pre>

<p>My test indicated no improvement in memory overhead, so I frustratedly called it quits. While brushing my teeth before bed, it hit me! I had unwittingly <em>re-introduced</em> recursive method calls. So, I hurried downstairs and reimplemented <code>def trampoline</code> to use a <code>while</code> loop and a buffer of bounces, an approach which didn&rsquo;t grow the Ruby execution context. Then the test result was much better.</p>

<p>Another consideration is the <em>overhead of Bounces</em> themselves. My first implementation creates a bounce before resolving each field. For very large responses, this will add a lot of overhead, especially when the field is a simple leaf value. This should be improved somehow.</p>

<h2>What about Speed?</h2>

<p>It turns out that visitors to the website don&rsquo;t care about backtrace size or Ruby heap size, they just care about waiting for webpages to load. Lucky for me, my benchmark includes some runtime measurements, and the results were basically the same:</p>

<pre><code class="text"># before
Calculating -------------------------------------
                         92.144  (Â±10.9%) i/s -    456.000  in   5.022617s
# after
Calculating -------------------------------------
                        113.529  (Â± 7.9%) i/s -    567.000  in   5.031847s
</code></pre>

<p>The runtime performance was very similar, almost within the margin of error. However, the consideration of Bounce overhead described above could cause <em>worse</em> performance in some cases.</p>

<h2>What&rsquo;s next?</h2>

<p>This code isn&rsquo;t <em>quite</em> ready for GraphQL-Ruby, but I think it&rsquo;s promising for a few reasons:</p>

<ul>
<li>The reduction of memory overhead and backtrace noise could pay off for very large, nested queries</li>
<li>I might be able to leverage bounces to give the caller more control over how GraphQL queries are executed. For example, at GitHub, we use GraphQL queries when rendering HTML pages. With some work, maybe we could alternate between bouncing GraphQL and rendering HTML, so we&rsquo;d get a better progressive rendering experience on the front end.</li>
</ul>


<p>However, one serious issue still needs to be addressed: what about the <code>Bounce</code>&rsquo;s <em>own</em> overhead? Allocating a new object for <em>every field execution</em> is already a performance issue in GraphQL-Ruby, and I&rsquo;m trying hard to remove it. So the implementation will need to be more subtle in that regard.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trip Report: Balkan Ruby 2018]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/06/14/trip-report-balkan-ruby-2018/"/>
    <updated>2018-06-14T15:02:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/06/14/trip-report-balkan-ruby-2018</id>
    <content type="html"><![CDATA[<p>This May, I had the opportunity to attend <a href="https://balkanruby.com/">Balkan Ruby</a> and present on my work with <a href="https://github.com/rmosolgo/graphql-ruby">graphql-ruby</a>.</p>

<!-- more -->


<p>Here are a few thoughts about the trip.</p>

<h2>The Conference</h2>

<p>Balkan Ruby was a big hit. Personally, some of my favorites were:</p>

<ul>
<li>Zach Holman&rsquo;s opening talk about datetimes and timezones (which became a <a href="https://zachholman.com/talk/utc-is-enough-for-everyone-right">blog post</a> and inspired a <a href="https://github.com/rmosolgo/graphql-ruby/pull/1566">GraphQL-Ruby ISO8601 scalar type</a>)</li>
<li>Sameer Deshmukh&rsquo;s presentation about various <a href="https://github.com/sciruby">SciRuby</a> projects</li>
<li>Marko BogdanoviÄ‡&rsquo;s talk about <a href="https://rubybench.org/">RubyBench</a>, which was a really cool project and made me want something like it for GraphQL-Ruby.</li>
</ul>


<p>One of my favorite parts of the conference was the code challenges set up by <a href="">Receipt Bank</a>, one of the sponsors.</p>

<p><img src="/images/balkan_ruby_2018/challenge.png" width="500"></p>

<p>Every few hours, a new, wacky challenge would go live. Although I didn&rsquo;t do well on them, I enjoyed working with a few new friends on different solutions, and seeing the creative things that other attendees submitted!</p>

<h2>The City</h2>

<p>Sofia was <strong>great</strong>. A beautiful city with interesting architecture, tons of trees and tasty food.</p>

<p>The Nevski Cathedral was built in the early 1900s to celebrate Russia&rsquo;s liberation of Bulgaria from the Ottomans:</p>

<p><img src="/images/balkan_ruby_2018/nevski.png" width="500"></p>

<p>Inside, a mural of Abraham and Isaac:</p>

<p><img src="/images/balkan_ruby_2018/abraham.png" width="500"></p>

<p>And St. Cyril and St. Methodius, creators of the Cyrillic alphabet, who are quite popular around here:</p>

<p><img src="/images/balkan_ruby_2018/saints.png" width="500"></p>

<p>I really enjoyed the different cathedrals. There&rsquo;s something cool about the different instructive artwork and &ldquo;sacred&rdquo; feeling of a beautiful building with incense burning. I wonder if modern American churches could do more to engage all of our senses.</p>

<p>Also, a bit of Soviet history found in a nearby park:</p>

<p><img src="/images/balkan_ruby_2018/soviet.png" width="500"></p>

<p>And here, some recently excavated Roman ruins, and the one remaining Turkish mosque downtown:</p>

<p><img src="/images/balkan_ruby_2018/ruins.png" width="500"></p>

<p>The mosque was right beside ruins of an old bathhouse. Apparently that&rsquo;s why Sofia was founded here &ndash; there were hot springs on the road between Rome and Constantinople, so the Romans set up camp (and called it Serdica).</p>

<p>And a fairly typical meal during my time there, a <em>shopska</em> salad (veggies with cheese, oil, and vinegar):</p>

<p><img src="/images/balkan_ruby_2018/food.png" width="500"></p>

<p>I can&rsquo;t say enough good things about the local dairy products. The cheese was soft and fresh and the yogurt was tart and refreshing.</p>

<h2>The Organizers</h2>

<p>My favorite part about programming conferences is meeting the smart, caring folks who make them possible, and Balkan Ruby was no exception.</p>

<p>The two main organizers, <a href="https://twitter.com/gsamokovarov">Genadi</a> and <a href="https://twitter.com/vestimir">Vestimir</a> were fantastic hosts (and experienced, since they got their start with Euruko a few years back). Besides that, I really enjoyed meeting the volunteers and learning a bit about life in Sofia.</p>

<p>One thing that stood out to me was the tradition behind the local liquor, rakia. It turns out that many families make it themselves, despite a law against owning stills. I&rsquo;ve been reading that peach wine was the traditional alcoholic drink for the earliest European arrivals to my area, so I decided to give it a shot this summer!</p>

<p>A big bonus was when Vestimir played trail guide for our hike up the nearby mountain, Mt. Vitosha. It turned out to be a gray day, but we had a blast anyways.</p>

<p>Some pictures of the trail:</p>

<p><img src="/images/balkan_ruby_2018/trail1.png" width="500"></p>

<p><img src="/images/balkan_ruby_2018/trail2.png" width="500"></p>

<p><img src="/images/balkan_ruby_2018/trail3.png" width="500"></p>

<p>Beautiful! But you could say were were <em>a bit</em> underdressed XD</p>

<p>At the summit, we were happy to find a lodge where some food was served.</p>

<p><img src="/images/balkan_ruby_2018/hut.png" width="500"></p>

<p>Some traditional bean soup, bread, <a href="https://en.wikipedia.org/wiki/Ljutenica">lyutenitsa</a>, cheese tea, and rakia never tasted so good.</p>

<p><img src="/images/balkan_ruby_2018/snack.png" width="500"></p>

<p>Enjoying a rest:</p>

<p><img src="/images/balkan_ruby_2018/group.png" width="500"></p>

<p>(Left-to-right: Andreas, Nynne, Sameer, Me and Vestimir)</p>

<p>And, pleasantly, we caught a nice view of Sofia on the way back down:</p>

<p><img src="/images/balkan_ruby_2018/overlook.png" width="500"></p>

<p>(You can even see the Nevski cathedral if you look closely!)</p>

<h2>Closing Thoughts</h2>

<p>Balkan Ruby was a big hit on all fronts: great people, great city, great technical content. Especially as a dairy lover, I&rsquo;ll take the next chance I get to go back! And I loved making some new friends, who I hope to see at future Ruby events.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Ripper parses variables]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/05/21/how-ripper-parses-variables/"/>
    <updated>2018-05-21T14:11:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/05/21/how-ripper-parses-variables</id>
    <content type="html"><![CDATA[<p>Ruby has a few different kinds of variables, and Ripper expresses them with a few different nodes.</p>

<!-- more -->


<p>Here are the different variables in Ruby:</p>

<pre><code class="ruby">a   # Local variable (or method call on self)
$a  # Global variable
A   # Constant
@a  # Instance variable
@@a # Class variable

# Bonus, not variables:
a()       # explicit method call (with parens) on implicit self
a b       # explicit method call (with args) on implicit self
self.a    # explicit method call (with dot) on explicit self
</code></pre>

<p>Here is how Ripper parses the above code:</p>

<pre><code class="ruby"># Ripper.sexp_raw(...) =&gt;

[:program,
 [:stmts_add,
  [:stmts_add,
   [:stmts_add,
    [:stmts_add,
     [:stmts_add,
      [:stmts_add,
       [:stmts_add,
        [:stmts_add, [:stmts_new], [:vcall, [:@ident, "a", [1, 0]]]],
        [:var_ref, [:@gvar, "$a", [2, 0]]]],
       [:var_ref, [:@const, "A", [3, 0]]]],
      [:var_ref, [:@ivar, "@a", [4, 0]]]],
     [:var_ref, [:@cvar, "@@a", [5, 0]]]],
    [:method_add_arg, [:fcall, [:@ident, "a", [8, 0]]], [:arg_paren, nil]]],
   [:command,
    [:@ident, "a", [9, 0]],
    [:args_add_block,
     [:args_add, [:args_new], [:vcall, [:@ident, "b", [9, 2]]]],
     false]]],
  [:call, [:var_ref, [:@kw, "self", [10, 0]]], :".", [:@ident, "a", [10, 5]]]]]
</code></pre>

<p>(<a href="https://ripper-preview.herokuapp.com/?code=a+++%23+Local+variable+%28or+method+call+on+self%29%0D%0A%24a++%23+Global+variable%0D%0AA+++%23+Constant%0D%0A%40a++%23+Instance+varaible%0D%0A%40%40a+%23+Class+variable%0D%0A%0D%0A%23+Bonus%2C+not+variables%3A%0D%0Aa%28%29+++++++%23+explicit+method+call+%28with+parens%29+on+implicit+self%0D%0Aself.a++++%23+explicit+method+call+%28with+dot%29+on+explicit+self">Ripper-preview</a>)</p>

<p>Let&rsquo;s check out those nodes.</p>

<h3>:vcall</h3>

<pre><code class="ruby"># a
[:vcall, [:@ident, "a", [1, 0]]]]
</code></pre>

<p>A <code>:vcall</code> is a bareword, either a local variable lookup <em>or</em> a method call on self. Used alone, this can only be determined at runtime, depending on the binding. If there&rsquo;s a local variable, it will be used. My guess is that <code>:vcall</code> is short for &ldquo;variable/call&rdquo;</p>

<p>Interestingly, there is a single-expression case which <em>could</em> be disambiguated statically, but Ripper still uses <code>:vcall</code>:</p>

<pre><code class="ruby"># a b
[:command,
 [:@ident, "a", [1, 0]],
 [:args_add_block,
  [:args_add, [:args_new], [:vcall, [:@ident, "b", [1, 2]]]],
  false]]]]
</code></pre>

<h3>:var_ref</h3>

<pre><code class="ruby"># $a
[:var_ref, [:@gvar, "$a", [1, 0]]]
# A
[:var_ref, [:@const, "A", [1, 0]]]
# @a
[:var_ref, [:@ivar, "@a", [4, 0]]]
# @@aa
[:var_ref, [:@cvar, "@@a", [5, 0]]]
</code></pre>

<p><code>:var_ref</code> (presumably &ldquo;variable reference&rdquo;) is shared by many of these examples, and can always be resolved to a <em>variable</em> lookup, never a method call.
Its argument tells what kind of lookup to do (global, constant, instance, class), and what name to look up.</p>

<h3>Method calls</h3>

<p>Some Ruby can be statically known to be a method call, <em>not</em> a variable lookup:</p>

<pre><code class="ruby"># a(), explicit method call (with parens) on implicit self
[:method_add_arg, [:fcall, [:@ident, "a", [1, 0]]], [:arg_paren, nil]]
# self.a, explicit method call (with dot) on explicit self
[:call, [:var_ref, [:@kw, "self", [1, 0]]], :".", [:@ident, "a", [1, 5]]]
# a b, explicit method call (with arguments) on implicit self
[:command,
   [:@ident, "a", [10, 0]],
   [:args_add_block,
    [:args_add, [:args_new], [:vcall, [:@ident, "b", [10, 2]]]],
    false]]]
</code></pre>

<p>In these cases, <code>:fcall</code>, <code>:call</code> and <code>:command</code> are used to represent definite method sends.</p>

<p>Interestingly, <code>:var_ref</code> is used for <code>self</code>, too.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Updating GitHub to GraphQL 1.8.0]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/04/09/updating-github-to-graphql-1-dot-8-0/"/>
    <updated>2018-04-09T09:52:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/04/09/updating-github-to-graphql-1-dot-8-0</id>
    <content type="html"><![CDATA[<p>GraphQL 1.8.0 was designed and built largely as a part of my work at GitHub. Besides designing the <a href="http://graphql-ruby.org/schema/class_based_api">new Schema definition API</a>, I migrated our codebase to use it. Here are some field notes from my migration.</p>

<!-- more -->


<p>If you want to know more about the motivations behind this work, check out this <a href="/blog/2018/03/25/why-a-new-schema-definition-api/">previous post</a>.</p>

<p>Below, I&rsquo;ll cover:</p>

<ul>
<li>The Process: in general, how I went about migrating our code</li>
<li>The Upgrader: how to run it and roughly how it&rsquo;s organized</li>
<li>Custom Transforms: extensions I made for the upgrader to work on GitHub-specific code</li>
<li>Fixes By Hand: bits of code that needed more work (some of these could be automated, but aren&rsquo;t yet!)</li>
<li>Porting Relay Types: using the class-based API for connections and edges</li>
<li>Migrating DSL extensions: how to support custom GraphQL extension in the new API</li>
</ul>


<h2>The Process</h2>

<p>GitHub&rsquo;s type definitions are separated into folders by type, for example: <code>objects/</code>, <code>unions/</code>, <code>enums/</code> (and <code>mutations/</code>). I worked through them one folder at a time. The <code>objects/</code> folder was big, so I did it twenty or thirty files at a time.</p>

<p>I had to do <code>interfaces/</code> last because of the nature of the new class-based schema. Interfaces modules' methods can&rsquo;t be added to legacy-style GraphQL object types. So, by doing interfaces last, I didn&rsquo;t have to worry about this compatibility issue.</p>

<p>Now that I remember it, I did the schema <em>first</em>, and by hand. It was a pretty easy upgrade.</p>

<p>When I started each section, I created a base class by hand. (There is some automated support for this, but I didn&rsquo;t use it.) Then, I ran the upgrader on some files and tried to run the test suite. There were usually two kinds of errors:</p>

<ul>
<li>Parse- or load-time errors which prevented the app from booting</li>
<li>Runtime errors which resulted in unexpected behavior or raised errors</li>
</ul>


<p>More on these errors below.</p>

<p>After upgrading a section of the schema, I opened a PR for review from the team. This was crucial: since I was working at such a large scale, it was easy for me to miss the trees for the forest. My teammates caught a lot of things during the process!</p>

<p>After a review, the PR would be merged into master. Since GraphQL 1.8.0 supports incremental migration, I could work through the code in chunks without a long running branch or feature flags.</p>

<h2>About the Upgrader</h2>

<p>Here&rsquo;s an overview of how the upgrader works. After reading the overview, if you want some specific examples, check out the <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/lib/graphql/upgrader/member.rb">source code</a>.</p>

<h3>Running The Upgrader</h3>

<p>The gem includes an auto-upgrader, spearheaded by the folks at <a href="https://hackerone.com">HackerOne</a> and refined during my use of it. It&rsquo;s encapsulated in a class, <code>GraphQL::Upgrader::Member</code>.</p>

<p>To use the upgrader, I added a Ruby script to the code base called <code>graphql-update.rb</code>:</p>

<pre><code class="ruby"># Usage:
#   ruby graphql-update.rb path/to/type_definition.rb
#
# Example:
#   # Upgrade `BlameRange`
#   ruby graphql-update.rb lib/platform/objects/blame_range.rb
#
#   # Upgrade based on a pattern (use quotes)
#   ruby graphql-update.rb "lib/platform/objects/blob_\*.rb"
#
#   # Upgrade one more file in this pattern (use quotes)
#   ruby graphql-update.rb 1 "lib/platform/objects/**.rb"

# Load the upgrader from local code, for easier trial-and-error development
# require "~/code/graphql-ruby/lib/graphql/upgrader/member"
# Load the upgrader from the Gem:
require "graphql/upgrader/member"

# Accept two arguments: next_files (optional), file_pattern (required)
file_pattern = ARGV[0]
if file_pattern =~ /\d+/
  next_files = file_pattern.to_i
  next_files_pattern = ARGV[1]
  "Upgrading #{next_files} more files in #{next_files_pattern}"
  filenames = Dir.glob(next_files_pattern)
else
  filenames = Dir.glob(file_pattern)
  next_files = nil
  puts "Upgrading #{filenames.join(", ")}"
end

# ...
# Lots of custom rules here, see below
# ...

CUSTOM_TRANSFORMS = {
  type_transforms: type_transforms,
  field_transforms: field_transforms,
  clean_up_transforms: clean_up_transforms,
  skip: CustomSkip,
}

upgraded = []
filenames.each do |filename|
  puts "Begin (#{filename})"
  # Read the file into a string
  original_text = File.read(filename)
  # Create an Upgrader with the set of custom transforms
  GraphQL::Upgrader::Member.new(original_text, **CUSTOM_TRANSFORMS)
  # Generate updated text
  transformed_text = upgrader.upgrade
  if transformed_text == original_text
    # No upgrade was performed
  else
    # If the upgrade was successful, update the source file
    File.write(filename, transformed_text)
    upgraded &lt;&lt; filename
  end
  puts "Done (#{filename})"
  if next_files &amp;&amp; upgraded.size &gt;= next_files
    # We've upgraded as many as we said we would
    break
  end
end
puts "Upgraded #{upgraded.size} files: \n#{upgraded.join("\n")}"
</code></pre>

<p>This script has two basic parts:</p>

<ul>
<li>Using <code>GraphQL::Upgrader::Member</code> with a set of custom transformations</li>
<li>Supporting code: accepting input, counting files, logging, etc</li>
</ul>


<p>In your own script, you can write whatever supporting code you want. The key part from GraphQL-Ruby is:</p>

<pre><code class="ruby"># Create an Upgrader with the set of custom transforms
GraphQL::Upgrader::Member.new(original_text, **CUSTOM_TRANSFORMS)
# Generate updated text
transformed_text = upgrader.upgrade
</code></pre>

<h3>The Pipeline</h3>

<p>The upgrader is structured as a pipeline: each step accepts a big string of input and returns a big string of output. Sometimes, a step does nothing and so its returned string is the same as the input string. In general, the transforms consist of two steps:</p>

<ul>
<li>Check whether the transform applies to the given input</li>
<li>If it does, copy the string and apply a find-and-replace to it (sometimes using RegExp, other times using the excellent <code>parser</code> gem.)</li>
</ul>


<p>You have a few options for customizing the transformation pipeline:</p>

<ul>
<li>Write new transforms and add them to the pipeline</li>
<li>Remove transforms from the pipeline</li>
<li>Re-use the built-in transforms, but give them different parameters, then replace the built-in one with your custom instance</li>
</ul>


<p>(The &ldquo;pipeline&rdquo; is just an array of instances or subclasses of <code>GraphQL::Upgrader::Transform</code>.)</p>

<p>We&rsquo;ll see cases of each below.</p>

<h3>Kinds of Transforms</h3>

<p>The upgrader accepts several types of transform pipelines:</p>

<pre><code class="ruby">CUSTOM_TRANSFORMS = {
  type_transforms: type_transforms,
  field_transforms: field_transforms,
  clean_up_transforms: clean_up_transforms,
  skip: CustomSkip,
}
</code></pre>

<ul>
<li><code>type_transforms</code> are run first, on the <em>entire</em> file.</li>
<li><code>field_transforms</code> are run second, but they receive <em>parts</em> of the type definition. They receive calls to <code>field</code>, <code>connection</code>, <code>return_field</code>, <code>input_field</code>, and <code>argument</code>. Fine-grained changes to field definition or argument definition go here.</li>
<li><code>clean_up_transforms</code> are run last, on the <em>entire</em> file. For example, there&rsquo;s a built-in <code>RemoveExcessWhitespaceTransform</code> which cleans up trailing spaces after other transforms have run.</li>
<li><code>skip:</code> has a special function: its <code>#skip?(input)</code> method is called and if it returns true, the text is not transformed at all. This allows the transformer to be idempotent: by default, if you run it on the same file over and over, it will update the file only <em>once</em>.</li>
</ul>


<h2>Custom Transforms</h2>

<p>Here are some custom transforms applied to our codebase.</p>

<h3>Handle a custom type-definition DSL</h3>

<p>We had a wrapper around <code>ObjectType.define</code> which attached metadata, linking the object type to a specific Rails model. The helper was called <code>define_active_record_type</code>. I wanted to take this:</p>

<pre><code class="ruby">module Platform
  module Objects
    Issue = define_active_record_type(-&gt; { ::Issue }) do
      # ...
    end
  end
end
</code></pre>

<p>And make it this:</p>

<pre><code class="ruby">module Platform
  module Objects
    class Issue &lt; Platform::Objects::Base
      model_name "Issue"
      # ...
    end
  end
end
</code></pre>

<p>Fortunately, this can be done with a pretty straightforward regular expression substitution. Here&rsquo;s the transform:</p>

<pre><code class="ruby"># Create a custom transform for our `define_active_record_type` factory:
class ActiveRecordTypeToClassTransform &lt; GraphQL::Upgrader::Transform
  # Capture: leading whitespace, type name, model name
  FIND_PATTERN = /^( +)([a-zA-Z_0-9:]*) = define_active_record_type\(-&gt; ?\{ ?:{0,2}([a-zA-Z_0-9:]*) ?\} ?\) do/
  # Restructure as a class, using the leading whitespace and adding the `model_name` DSL
  REPLACE_PATTERN = "\\1class \\2 &lt; Platform::Objects::Base\n\\1  model_name \"\\3\""

  def apply(input_text)
    # It's safe to apply this transform to _all_ input,
    # since it's a no-op if `FIND_PATTERN` is missing.
    input_text.sub(FIND_PATTERN, REPLACE_PATTERN)
  end
end
</code></pre>

<p>Then, in <code>graphql-update.rb</code>, this transform was put <em>first</em> in the list:</p>

<pre><code class="ruby"># graphql-update.rb
type_transforms = GraphQL::Upgrader::Member::DEFAULT_TYPE_TRANSFORMS.dup
type_transforms.unshift(ActiveRecordTypeToClassTransform)
</code></pre>

<p>Also, for this to work, I added the <code>def self.model_name(name)</code> helper to the base class.</p>

<h3>Renaming a Custom Field Method</h3>

<p>We have a helper for adding URL fields called <code>define_url_field</code>. I decided to rename this to <code>url_fields</code>, since these days it creates <em>two</em> fields.</p>

<p>The arguments are the same, so it was a simple substitution:</p>

<pre><code class="ruby">class UrlFieldTransform &lt; GraphQL::Upgrader::Transform
  def apply(input_text)
    # Capture the leading whitespace and the rest of the line,
    # then insert the new name where the old name used to be
    input_text.gsub(/^( +)define_url_field( |\()/, "\\1url_fields\\2")
  end
end
</code></pre>

<p>This transform didn&rsquo;t interact with any other transforms, so I added it to <code>clean_up_transforms</code>, so it would run last:</p>

<pre><code class="ruby"># Make a copy of the built-in arry
clean_up_transforms = GraphQL::Upgrader::Member::DEFAULT_CLEAN_UP_TRANSFORMS.dup
# Add my custom transform to the end of the array
clean_up_transforms.push(UrlFieldTransform)
</code></pre>

<h3>Moving DSL methods to keywords</h3>

<p>We have a few DSL methods that, at the time, were easier to implement as keyword arguments. (Since then, the API has changed a bit. You can implement DSL methods on your fields by extending <code>GraphQL::Schema::Field</code> and setting that class as <code>field_class</code> on your base Object, Interface and Mutation classes.)</p>

<p>I wanted to transform:</p>

<pre><code class="ruby">field :secretStuff, types.String do
  visibility :secret
end
</code></pre>

<p>To:</p>

<pre><code class="ruby">field :secretStuff, types.String, visibility: :secret
</code></pre>

<p>(Later, a built-in upgrader would change <code>secretStuff</code> to <code>secret_stuff</code> and <code>types.String</code> to <code>String, null: true</code>.)</p>

<p>To accomplish this, I reused a built-in transform, <code>ConfigurationToKwargTransform</code>, adding it to <code>field_transforms</code>:</p>

<pre><code class="ruby"># Make a copy of the built-in list of defaults
field_transforms = GraphQL::Upgrader::Member::DEFAULT_FIELD_TRANSFORMS.dup
# Put my custom transform at the beginning of the list
field_transforms.unshift(GraphQL::Upgrader::ConfigurationToKwargTransform.new(kwarg: "visibility"))
</code></pre>

<p>In fact, there were several configuration methods moved this way.</p>

<h3>Custom Skip</h3>

<p>As I was working through the code, some files were tougher than others. So, I decided to skip them. I decided that a magic comment:</p>

<pre><code class="ruby"># @skip-auto-upgrade
</code></pre>

<p>would cause a file to be skipped. To implement this, I made a custom skip class:</p>

<pre><code class="ruby">class CustomSkip &lt; GraphQL::Upgrader::SkipOnNullKeyword
  def skip?(input_text)
    super(input_text) || input_text.include?("@skip-auto-upgrade")
  end
end
</code></pre>

<p>And passed it as <code>skip:</code> to the upgrader. Then, later, I removed the comment and tried again. (Fortunately, my procrastination paid off because the upgrader was improved in the meantime!)</p>

<h2>Fixes by Hand</h2>

<p>As I worked, I improved the upgrader to cover as many cases as I could, but there are still a few cases that I had to upgrade by hand. I&rsquo;ll list them here. If you&rsquo;re really dragged down by them, consider opening an issue on GraphQL-Ruby to talk about fixing them. I&rsquo;m sure they <em>can</em> be fixed, I just didn&rsquo;t get to it!</p>

<p>If you want to fix one of these issues, try to replicate the issue by adding to an example <code>spec/fixtures/upgrader</code> and then getting a failing test. Then, you could update the upgrader code to fix that broken test.</p>

<h3>Accessing Arguments By Method</h3>

<p>Arguments could be accessed by method to avoid typos. However, now, since arguments are a Ruby keyword hash, they don&rsquo;t have methods corresponding to their keys.</p>

<p>Unfortunately, the upgrader doesn&rsquo;t do anything about this, it just leaves them there and you get a <code>NoMethodError</code> on <code>Hash</code>.</p>

<p>This could almost certainly be fixed by improving this find-and-replace in <code>ResolveProcToMethodTransform</code>:</p>

<pre><code class="ruby"># Update Argument access to be underscore and symbols
# Update `args[...]` and `args.key?`
method_body = method_body.gsub(/#{args_arg_name}(?&lt;method_begin&gt;\.key\?\(?|\[)["':](?&lt;arg_name&gt;[a-zA-Z0-9_]+)["']?(?&lt;method_end&gt;\]|\))?/) do
 # ...
end
</code></pre>

<p>It only updates a few methods on <code>args</code>, but I bet a similar find-and-replace could replace <em>other</em> method calls, too.</p>

<h3>Argument Usages Outside of Type Definitions</h3>

<p>Sometimes, we take GraphQL arguments and pass them to helper methods:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  Some::Helper.call(obj, args)
}
</code></pre>

<p>However when this was transformed to:</p>

<pre><code class="ruby">def do_stuff(**arguments)
  Some::Helper.call(@object, arguments)
end
</code></pre>

<p>It would break, because the new <code>arguments</code> value is a Ruby hash with underscored, symbol keys. So, if <code>Some::Helper</code> was using camelized strings to get values, it would stop working.</p>

<p>The upgrader can&rsquo;t really do anything there, since it&rsquo;s not analyzing the codebase. In my case, these were readily apparent because of failing tests, so I went and fixed them.</p>

<h3>context.add_error</h3>

<p>We have some fields that add to the <code>"errors"</code> key <em>and</em> return values, they used <code>ctx.add_error</code> to do so:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  begin
    obj.count_things
  rescue BackendIsBrokenError
    ctx.add_error(GraphQL::ExecutionError.new("Not working!"))
    0
  end
}
</code></pre>

<p>When upgraded, it doesn&rsquo;t work quite right:</p>

<pre><code class="ruby">def count_things
  begin
    @object.count_things
  rescue BackendIsBrokenError
    @context.add_error(GraphQL::ExecutionError.new("Not working!"))
    0
  end
end
</code></pre>

<p>(If you don&rsquo;t have to return a value, use <code>raise</code> instead, then you can stop reading this part!)</p>

<p>The problem is that <code>@context</code> is not a <em>field-specific</em> context anymore. Instead, it&rsquo;s the query-level context. (This is downside of the new API: we don&rsquo;t have a great way to pass in the field context anymore.)</p>

<p>To address this kind of issues, <code>field</code> accepts a keyword called <code>extras:</code>, which contains a array of symbols. In the case above, we could use <code>:execution_errors</code>:</p>

<pre><code class="ruby">field :count_things, Integer, null: false, extras: [:execution_errors]
def count_things(execution_errors:)
  @object.count_things
rescue BackendIsBrokenError
  execution_errors.add("Not working!")
  0
end
</code></pre>

<p>So, <code>execution_errors</code> was injected into the field as a keyword. It <em>is</em> field-level, so adding errors there works as before.</p>

<p>Other extras are <code>:irep_node</code>, <code>:parent</code>, <code>:ast_node</code>, and <code>:arguments</code>. It&rsquo;s a bit of a hack, but we need <em>something</em> for this!</p>

<h3>Accessing Connection Arguments</h3>

<p>By default, connection arguments (like <code>first</code>, <code>after</code>, <code>last</code>, <code>before</code>) are <em>not</em> passed to the Ruby methods for implementing fields. This is because they&rsquo;re generally used by the automagical (ðŸ˜–) connection wrappers, not the resolve functions.</p>

<p>But, sometimes you just <em>need</em> those old arguments!</p>

<p>If you use <code>extras: [:arguments]</code>, the legacy-style arguments will be injected as a keyword:</p>

<pre><code class="ruby"># `arguments` is the legacy-style Query::Arguments instance
# `field_arguments` is a Ruby hash with symbol, underscored keys.
def things(arguments:, **field_arguments)
  arguments[:first] # =&gt; 5
  # ...
end
</code></pre>

<h3>Fancy String Descriptions</h3>

<p>The upgrader does fine when the description is a <code>"..."</code> or <code>'...'</code> string. But in other cases, it was a bit wacky.</p>

<p>Strings built up with <code>+</code> or <code>\</code> always broke. I had to go back by hand and join them into one string.</p>

<p>Heredoc strings often <em>worked</em>, but only by chance. For example:</p>

<pre><code class="ruby">field :stuff, types.Int do
  description &lt;&lt;~MD
    Here's the stuff
  MD
end
</code></pre>

<p>Would be transformed to:</p>

<pre><code class="ruby">field :stuff, Integer, description: &lt;&lt;~MD, null: true
    Here's the stuff
  MD
</code></pre>

<p>This is valid Ruby, but a bit tricky. This could definitely be improved: since I started my project, GraphQL 1.8 was extended to support <code>description</code> as a <em>method</em> as well as a keyword. So, the upgrader could be improved to leave descriptions in place if they&rsquo;re fancy strings.</p>

<h3>Removed Comments From the Start of Resolve Proc</h3>

<p>I hacked around with the <code>parser</code> gem to transform <code>resolve</code> procs into instance methods, but there&rsquo;s a bug. A proc like this:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  # Do stuff
  obj.do_stuff { stuff }
}
</code></pre>

<p>Will be transformed to:</p>

<pre><code class="ruby">def stuff
  @object.do_stuff { stuff }
end
</code></pre>

<p>Did you see how the comment was removed? I think I&rsquo;ve somehow wrongly detected the start of the proc body, so that the comment was left out.</p>

<p>In my case, I re-added those comments by hand. But it could probably be fixed in <code>GraphQL::Upgrader::ResolveProcToMethodTransform</code>.</p>

<h3>Hash Reformating?</h3>

<p>I&rsquo;m not sure why, but sometimes a hash of arguments like:</p>

<pre><code class="ruby">obj.do_stuff(
  a: 1,
  b: 2,
  c: 3,
  d: 4,
)
</code></pre>

<p>would be reorganized to</p>

<pre><code class="ruby">obj.do_stuff(
  a: 1,
  b: 2, c: 3, d: 4,
)
</code></pre>

<p>I have no idea why, and I didn&rsquo;t look into it, I just fixed it by hand.</p>

<h3>Issues with Connection DSL</h3>

<p>We have a DSL for making connections, like:</p>

<pre><code class="ruby">Connections.define(Objects::Issue)
</code></pre>

<p>Sometimes, when this connection was inside a proc, it would be wrongly transformed to:</p>

<pre><code class="ruby">field :issues, Connections.define(Objects::Issue) }, ,null: true
</code></pre>

<p>This was invalid Ruby, so the app wouldn&rsquo;t boot, and I would fix it by hand.</p>

<h2>Porting Relay Types</h2>

<p>Generating connection and edge types with the <code>.connection_type</code>/<code>.define_connection</code> and <code>.edge_type</code>/<code>.define_edge</code> methods will work fine with the new API, but if you want to migrate them to classes, you can do it.</p>

<p>It&rsquo;s on my radar because I want to remove our DSL extensions, and that requires updating our custom connection edge types.</p>

<p>Long story, short, it Just Workâ„¢ed with the class-based API. The approach was:</p>

<ul>
<li>Add a base class inheriting from our <code>BaseObject</code></li>
<li>Use the new base class&rsquo;s <code>def self.inherited</code> hook to add connection- and edge-related behaviors</li>
<li>Run the upgrader on edge and connection types, then go back and do some manual find-and-replaces to make them work right</li>
</ul>


<p>So, I will share my base classes in case that helps. Sometime it will be nice to upstream this to GraphQL-Ruby, but I&rsquo;m not sure how to do it now.</p>

<p>Base connection class:</p>

<pre><code class="ruby">module Platform
  module Connections
    class Base &lt; Platform::Objects::Base
      # For some reason, these are needed, they call through to the underlying connection wrapper.
      extend Forwardable
      def_delegators :@object, :cursor_from_node, :parent

      # When this class is extended, add the default connection behaviors.
      # This adds a new `graphql_name` and description, and searches
      # for a corresponding edge type.
      # See `.edge_type` for how the fields are added.
      def self.inherited(child_class)
        # We have a convention that connection classes _don't_ end in `Connection`, which
        # is a bit confusing and results in naming conflicts.
        # To avoid a GraphQL conflict, override `graphql_name` to end in `Connection`.
        type_name = child_class.name.split("::").last
        child_class.graphql_name("#{type_name}Connection")

        # Use `require_dependency` so that the types will be loaded, if they exist.
        # Otherwise, `const_get` may reach a top-level constant (eg, `::Issue` model instead of `Platform::Objects::Issue`).
        # That behavior is removed in Ruby 2.5, then we can remove these require_dependency calls too.
        begin
          # Look for a custom edge whose name matches this connection's name
          require_dependency "lib/platform/edges/#{type_name.underscore}"
          wrapped_edge_class = Platform::Edges.const_get(type_name)
          wrapped_node_class = wrapped_edge_class.fields["node"].type
        rescue LoadError =&gt; err
          # If the custom edge file doesn't exist, look for an object
          begin
            require_dependency "lib/platform/objects/#{type_name.underscore}"
            wrapped_node_class = Platform::Objects.const_get(type_name)
            wrapped_edge_class = wrapped_node_class.edge_type
          rescue LoadError =&gt; err
            # Assume that `edge_type` will be called later
          end
        end

        # If a default could be found using constant lookups, generate the fields for it.
        if wrapped_edge_class
          if wrapped_edge_class.is_a?(GraphQL::ObjectType) || (wrapped_edge_class.is_a?(Class) &amp;&amp; wrapped_edge_class &lt; Platform::Edges::Base)
            child_class.edge_type(wrapped_edge_class, node_type: wrapped_node_class)
          else
            raise TypeError, "Missed edge type lookup, didn't find a type definition: #{type_name.inspect} =&gt; #{wrapped_edge_class.inspect}"
          end
        end
      end

      # Configure this connection to return `edges` and `nodes` based on `edge_type_class`.
      #
      # This method will use the inputs to create:
      # - `edges` field
      # - `nodes` field
      # - description
      #
      # It's called when you subclass this base connection, trying to use the
      # class name to set defaults. You can call it again in the class definition
      # to override the default (or provide a value, if the default lookup failed).
      def self.edge_type(edge_type_class, edge_class: GraphQL::Relay::Edge, node_type: nil)
        # Add the edges field, can be overridden later
        field :edges, [edge_type_class, null: true],
          null: true,
          description: "A list of edges.",
          method: :edge_nodes,
          edge_class: edge_class

        # Try to figure out what the node type is, if it wasn't provided:
        if node_type.nil?
          if edge_type_class.is_a?(Class)
            node_type = edge_type_class.fields["node"].type
          elsif edge_type_class.is_a?(GraphQL::ObjectType)
            # This was created with `.edge_type`
            node_type = Platform::Objects.const_get(edge_type_class.name.sub("Edge", ""))
          else
            raise ArgumentError, "Can't get node type from edge type: #{edge_type_class}"
          end
        end

        # If it's a non-null type, remove the wrapper
        if node_type.respond_to?(:of_type)
          node_type = node_type.of_type
        end

        # Make the `nodes` shortcut field, which can be overridden later
        field :nodes, [node_type, null: true],
          null: true,
          description: "A list of nodes."

        # Make a nice description
        description("The connection type for #{node_type.graphql_name}.")
      end

      field :page_info, GraphQL::Relay::PageInfo, null: false, description: "Information to aid in pagination."

      # By default this calls through to the ConnectionWrapper's edge nodes method,
      # but sometimes you need to override it to support the `nodes` field
      def nodes
        @object.edge_nodes
      end
    end
  end
end
</code></pre>

<p>Base edge class:</p>

<pre><code class="ruby">module Platform
  module Edges
    class Base &lt; Platform::Objects::Base
      # A description which is inherited and may be overridden
      description "An edge in a connection."

      def self.inherited(child_class)
        # We have a convention that edge classes _don't_ end in `Edge`,
        # which is a little bit confusing, and would result in a naming conflict by default.
        # Avoid the naming conflict by overriding `graphql_name` to include `Edge`
        wrapped_type_name = child_class.name.split("::").last
        child_class.graphql_name("#{wrapped_type_name}Edge")
        # Add a default `node` field, assuming the object type name matches.
        # If it doesn't match, you can override this in subclasses
        child_class.field :node, "Platform::Objects::#{wrapped_type_name}", null: true, description: "The item at the end of the edge."
      end

      # A cursor field which is inherited
      field :cursor, String,
        null: false,
        description: "A cursor for use in pagination."
    end
  end
end
</code></pre>

<h2>Migrating DSL Extensions</h2>

<p>We have several extensions to the GraphQL-Ruby <code>.define</code> DSL, for example, <code>visibility</code> controls who can see certain types and fields and <code>scopes</code> maps OAuth scopes to GraphQL types.</p>

<p>The difficulty in porting extensions comes from the implementation details of the new API. For now, definition classes are factories for legacy-style type instances. Each class has a <code>.to_graphql</code> method which is called <em>once</em> to return a legacy-style definition. To maintain compatibility, you have to either:</p>

<ul>
<li>Modify the derived legacy-style definition to reflect configurations on the class-based definition; OR</li>
<li>Update your runtime code to <em>stop</em> checking for configurations on the legacy-style definition and <em>start</em> checking for configurations on the class-based definition.</li>
</ul>


<p>Eventually, legacy-style definitions will be phased out of GraphQL-Ruby, but for now, they both exist in this way in order to maintain backwards compatibility and gradual adoptability.</p>

<p>In the mean time, you can go between class-based and legacy-style definitions using <code>.graphql_defintion</code> and <code>.metadata[:type_class]</code>, for example:</p>

<pre><code class="ruby">class Project &lt; BaseObject
  # ...
end

legacy_type = Project.graphql_definition
# #&lt;GraphQL::ObjectType&gt; instance
legacy_type.metadata[:type_class]
# `Project` class
</code></pre>

<h3>The Easy Way: <code>.redefine</code></h3>

<p>The easiest way to retain compatibility is to:</p>

<ul>
<li>Add a class method to your base classes which accept some configuration and put it in instance variables</li>
<li>Override <code>.to_graphql</code> to call super, and then pass the configuration to <code>defn.redefine(...)</code>, then return the redefined type.</li>
</ul>


<p>After my work on our code, I extracted this into a <a href="http://graphql-ruby.org/type_definitions/extensions.html#customization-compatibility">backport of <code>accepts_definition</code></a></p>

<p>You can take that approach for a try, for example:</p>

<pre><code class="ruby">class BaseObject &lt; GraphQL::Schema::Object
  # Add a configuration method
  def self.visibility(level)
    @visibility = level
  end

  # Re-apply the configuration
  def self.to_graphql
    type_defn = super
    # Call through to the old extension:
    type_defn = type_defn.redefine(visibilty: @visibility)
    # Return the redefined type:
    type_defn
  end
end

# Then, use it in type definitions:
class Post &lt; BaseObject
  visibility(:secret)
end
</code></pre>

<h3>The Hard Way: <code>.metadata[:type_class]</code></h3>

<p>An approach I haven&rsquo;t tried yet, but I will soon, is to move the &ldquo;source of truth&rdquo; to the the class-based definition. The challenge here is that class-based definitions are not really used during validation and execution, so how can you reach configuration values on those classes?</p>

<p>The answer is that if a legacy-style type was derived from a class, that class is stored as <code>metadata[:type_class]</code>. For example:</p>

<pre><code class="ruby">class Project &lt; BaseObject
  # ...
end
legacy_defn = Project.graphql_definition # Instance of GraphQL::ObjectType, just like `.define`
legacy_defn.metadata[:type_class] # `Project` class from above
</code></pre>

<p>So, you could update runtime code to read configurations from <code>type_defn.metadata[:type_class]</code>.</p>

<p>Importantly, <code>metadata[:type_class]</code> will be <code>nil</code> if the type <em>wasn&rsquo;t</em> derived from a class, so this approach is tough to use if some definitions are still using the <code>.define</code> API.</p>

<p>I haven&rsquo;t implemented this yet, but I will be doing it in the next few weeks so we can simplify our extensions and improve boot time.</p>

<h2>The End</h2>

<p>I&rsquo;m still wrapping up some loose ends in the codebase, but I thought I&rsquo;d share these notes in case they help you in your upgrade. If you run into trouble on anything mentioned here, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> on GraphQL-Ruby! I really want to support a smooth transition to this new API.</p>
]]></content>
  </entry>
  
</feed>
